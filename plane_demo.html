<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - plane demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
    <div id="container"></div>

		<script src="three.js-master/build/three.js"></script>

    <script src="three.js-master/examples/js/renderers/Projector.js"></script>
		<script src="three.js-master/examples/js/renderers/CanvasRenderer.js"></script>

    <script src="three.js-master/examples/js/controls/TrackballControls.js"></script>

    <script src="three.js-master/examples/js/Detector.js"></script>
    <script src="three.js-master/examples/js/libs/stats.min.js"></script>

		<script>
      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;
			var plane;
			var mouse, raycaster, isShiftDown = false;
      var stats;
      var controls;

			var cubeGeometry = new THREE.BoxGeometry( 50, 50, 50 );
			var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0x00ff80, overdraw: 0.5 } );

      var objects = [];

			init();
      animate();
			render();

			function init() {

        // camera
        camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( new THREE.Vector3() );

        // camera control
        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );

        // world
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				// Grid
				var gridHelper = new THREE.GridHelper( 1000, 20 ); //Create grid helper on the canvas. The first parameter represents n*n plane; the second represnts the size of every grid
				scene.add( gridHelper ); //add the grid helper to the scene

        // create a plane, which is a foundation for drawing cubes
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );
				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );
				objects.push( plane );
				// var material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );

        // Lights
				var ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );
				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );
				var directionalLight = new THREE.DirectionalLight( 0x808080 );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

        // renderer
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
        container = document.getElementById( 'container' );
				container.appendChild(renderer.domElement);

        // add a FPS monitor on the top left
        stats = new Stats();
        container.appendChild( stats.dom );

        // eventlistener
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}

      //Resize the size of the browser
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
        controls.handleResize();
				render();
			}

      //camera rotation animation
      function animate() {
        requestAnimationFrame( animate );
        controls.update();
      }


			function onDocumentMouseDown( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					var intersect = intersects[ 0 ];
					if ( isShiftDown ) {
						if ( intersect.object != plane ) {
							scene.remove( intersect.object );
							objects.splice( objects.indexOf( intersect.object ), 1 );
						}
					} else {
						var voxel = new THREE.Mesh( cubeGeometry, cubeMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );
						objects.push( voxel );
					}
					render();
				}
			}

			function onDocumentKeyDown( event ) {
				switch( event.keyCode ) {
					case 16: isShiftDown = true; break;
				}
			}

			function onDocumentKeyUp( event ) {
				switch( event.keyCode ) {
					case 16: isShiftDown = false; break;
				}
			}

			function render() {
				renderer.render( scene, camera );
        stats.update();
			}
		</script>

	</body>
</html>
